main(/)
	
	
	
	*** *bool_input_output_weight_test(/)
	*** *bool_rand_test(/)
	*** *bool_moebius_test(/)
	*** *bool_pua_test(/)
	*** *test_printANF(/)
	*** *test_degree(/)
	*** *test_betterAffineZoom(/)
	*** *test_nonlinearity(/)
	*** *test_cor(/)
	*** *test_autocor(/)
	*test_propCrit(/)
	*** test_(/)
**


*** TODO:
*** ----------------------------------------------------
*** (*) порядок корреляционной иммунности (p.29 theorem 1.6)
*** (*) соверш. нелинейность (p.41)
*** (*) автокорреляция (p.51)
*** (*) степень распространения (p.56)
*** ----------------------------------------------------



*** *************************************************************************************
*** **************************************  Алгоритмы  **********************************
*** *************************************************************************************

*** Если L# булевый вектор, тогда в первом элементе находится количество переменных в нём, а размер булевого вектора = 1 < L#.0


test_autocor(/)
	@+L1(100)
	@+F2(100)
	*** OQ2 @'01110101101010101010101010101001'>F2
	OQ2 @'11000110'>F2
	*** OQ2 @'11111111'>F2
	*BFinput(F2/L1)
	1<L1.0+5=t *** 5 под запас, по сути не нужно, но на всякий случай
	@+L3(t)
	*** *BFoutput(L1/) /'\n'>C
	*BFoutput_string(L1/) /'\n'>C
	*BFautocor(L1/L3)
	*sprint_complex(L3/) /'\n'>C
	
**

*** /' = '>C *printf(/) /'\n'>C
*** Автокорреляция
*** 
*** 
*** 
BFautocor(L1/L2)
	L1.0=m 1<m=n
	*** @+L3(n) n=Q3
	*BFpua(L1/L2)
	Oi Q2-1=t
	P1
		?(i>t)2 L2i*L2i=L2i Di ?=1
	P2
		*BFpuaAlg(L2, 1/L2)
**


*** ****************************************************************************************
*** *****************************  Propagation Criteria  **********************************
*** ****************************************************************************************


test_propCrit(/)
	@+L1(100)
	@+F2(100)
	*** OQ2 @'01110101101010101010101010101001'>F2
	OQ2 @'11000110'>F2
	*** OQ2 @'11111111'>F2
	*BFinput(F2/L1)
	*** *BFoutput(L1/) /'\n'>C
	*BFoutput_string(L1/) /'\n'>C
	*BFpropCrit(L1/m)
	/'m = '>C *printf(m/) /'\n'>C
**


*** ****************************************************************************************



*** Обёртка алгоритм критерий распространения(Propagation Criterion Algotithm)
*** 
*** 
BFpropCrit(L1/m)
	Om 1<L1.0=n
	*BFweight(L1/t)
	?(t=n)1 ?(t=0)1
	@+L2(n)
	*BFautocor(L1/L2)
	*sprint_complex(L2/) /'\n'>C
	*BFcorAlg(L2, m/m)
	P1
**


*** ****************************************************************************************


*** Алгоритм критерий распространения(Propagation Criterion Algotithm)
*** 
*** 
BFpropCritAlg(/)
	
	
	
**


*** ****************************************************************************************
*** **********************************  Affine Zooming *************************************
*** ****************************************************************************************


test_betterAffineZoom(/)
	@+L1(100)
	@+L2(100)
	@+L3(100)
	@+F4(100)
	*** OQ4 @'01110101101010101010101010101001'>F4
	OQ4 @'01111010'>F4
	*BFinput(F4/L1)
	*** *BFoutput(L1/) /'\n'>C
	*BFoutput_string(L1/) /'\n'>C
	*BFbetterAffineZoom(L1/L2)
	/'L1 = '>C *BFoutput_string(L1/) /'\n'>C
	/'L1 = '>C *BFoutput_string(L2/) /'\n'>C
	*** /'n = '>C *printf(n/) /'\n'>C
	
**



*** ****************************************************************************************



*** обёртка для алгоритма наилучшего аффинного приближения
BFbetterAffineZoom(L1/L2)
	1<L1.0=n
	@+L3(n)
	*BFpua(L1/L3)
	*BFpuaMaxSearch(L3/i, x)
	L1.0=L2.0 1=Q2
	*BFbetterAffineZoomAlg(L1, i/L2)
	/'n = '>C *printf(n/) /'\n'>C
**


*** ****************************************************************************************


*** Алгоритм наилучшего аффинного приближения
*** L1 - пустой булев вектор в который будет записан результат
*** l - индекс наибольшего значения из вектора после преобразования Уолша - Адамара
*** j - индекс текущего элемента
*** s - <= 32 возможных бита
BFbetterAffineZoomAlg(L1, l/L2)
	?(Q1<1)6 ?(L1.0<1)6
	Os=Z=i=c 1<L1i=m Di
	*** m:32+2=Q1-1=n ?(Z=0)1 Q1-1=Q1-1=n *** n для условия i не больше Q1-1
	*** m:32+2=Q1 количество элементов в символьном комплексе под
	*** значения функции с учётом того, что результат деления может быть
	*** с остатком. + 1 (нулевой элемент - количество переменных)
	P1
		Ox=j *** ?(i>n) может быть не нужно из-за (s>m)
	P2
		*** c - проверка, если в z уже записана одна переменная, значит
		*** следует делать сложение по модулю 2 иначе записать в z совпадение, c={0, 1}
		L1.0-k-1=t 1<t&l=y ?(y=0)4 ?(c=1)3 1<t&s>t=z Dc ?=4
	P3
		1<t&s>t^z=z
	P4
		Dk ?(k<L1.0)2
		z<j|x=x Ds Dj Ok=c ?(j>31)5 ?(s<m)2
	P5
		x=L2i Di=Q2 ?(s<m)1
	P6
**


*** ****************************************************************************************



*** значение по модулю (абсолютное значение)
absolut(x/y)
	x=y
	x&I31=t ?(t=0)2
	P1
		x~=y
	P2
**


*** ****************************************************************************************
*** ***********************************  NonLinearity  *************************************
*** ****************************************************************************************


test_nonlinearity(/)
	@+L1(100)
	@+L2(100)
	@+L3(100)
	@+F4(100)
	OQ4 @'01110101101010101010101010101001'>F4
	*** OQ4 @'01111010'>F4
	*BFinput(F4/L1)
	*** *BFoutput(L1/) /'\n'>C
	*BFoutput_string(L1/) /'\n'>C
	*BFnonlinearity(L1/n)
	/'n = '>C *printf(n/) /'\n'>C
	
	
**


*** ****************************************************************************************



*** Вычисление значения нелинейности булевой функции
*** 
*** 
BFnonlinearity(L1/n)
	1<L1.0=n
	@+L2(n)
	*BFpua(L1/L2)
	*sprint_complex(L2/) /'\n'>C
	*BFpuaMaxSearch(L2/i, v)
	/'i = '>C *printf(i/) /'\n'>C
	/'v = '>C *printf(v/) /'\n'>C
	L1.0-1=n 1<n=n v/2=t n-t=n
**


*** ****************************************************************************************


*** Поиск наибольшего элемента в векторе после преобразования Уолша - Адамара
*** Используется для поиска наибольшего аффинного приближения и нелинейности
*** L1 - вектор после преобразования Уолша - Адамара
*** n - длина комплекса L1
*** i - индекс найденного элемента
*** v - (value) значение элемента
BFpuaMaxSearch(L1/j, v)
	Oi=j *absolut(L1i/v) Di Q1-1=m
	P1 
		?(i>m)2
		*** /'L1i = '>C *printf(L1i/) /'\n'>C
		*absolut(L1i/u) Di ?(u<=v)1 u=v i-1=j ?=1	*** если элемент больше
	*** предыдущего, запоминается его значение и индекс
	P2
**



*** ****************************************************************************************
*** ************************************  Correlinearity  **********************************
*** ****************************************************************************************


test_cor(/)
	@+L1(100)
	@+F2(100)
	*** OQ2 @'01110101101010101010101010101001'>F2
	OQ2 @'11000110'>F2
	*** OQ2 @'11111111'>F2
	*BFinput(F2/L1)
	*** *BFoutput(L1/) /'\n'>C
	*BFoutput_string(L1/) /'\n'>C
	*BFcor(L1/m)
	/'m = '>C *printf(m/) /'\n'>C
	
	
**

*** ****************************************************************************************


*** Обёртка для алгоритма порядок корреляционной иммунности
*** 
*** 
BFcor(L1/m)
	L1.0=m 1<m=n
	*BFweight(L1/t)
	?(t=n)1 ?(t=0)1
	@+L2(n)
	*BFpua(L1/L2)
	*sprint_complex(L2/) /'\n'>C
	*BFcorAlg(L2, m/m)
	P1
**


*** ****************************************************************************************


*** Степень корреляционной иммунности. Алгоритм
*** Также используется при вычислении критерия распространения
*** 
BFcorAlg(L1, l/m)
	l-1=n 1=i
	P1 ?(i>n)6
		1<i-1=d l-i=t d<t=b ?(L1b#0)7
	P2
		?(b=d)5 b+1&b=c Ow c-1^b=q
	P3
		?(q=0)4 q-1&q=q Dw ?=3
	P4
		w-2=w b+1^b<1+1<w^c=b ?(L1b#0)7 ?=2
	P5
		Di ?=1
	P6
		l=i
	P7
		i-1=m
**


*** ****************************************************************************************
*** ****************************************  Degree  **************************************
*** ****************************************************************************************


test_degree(/)
	@+L1(100)
	@+L2(100)
	@+L3(100)
	@+F4(100)
	*** OQ4 @'01110101101010101010101010101001'>F4
	OQ4 @'01110101101010101010101010101000'>F4
	*BFinput(F4/L1)
	*BFdegree(L1/d)
	/'d = '>C *printf(d/) /'\n'>C
	
**



*** ****************************************************************************************


*** как посчитать количество переменных(степень)?
*** степень булевой функции
*** L1 - булев вектор, после преобразования Мёбиуса
*** d - степень булева вектора
BFdegree(L1/d)
	Q2=n
	@+L2(n)
	*mobiusTransform(L1/L2)
	*BFoutput_string(L2/) /'\n'>C
	Od L2.0=n Q2-1=l
	31=i *** предполагается, что n > 5 (количество переменных больше 5), значит в булевой функции >= 32 значений
	*** но, если меньше, берётся значение 2^n
	?(n>4)1 1<n-1=i
	*** /'i = '>C *printf(i/) /'\n'>C
	P1 ?(L2l=0)2
		*** /'i = '>C *printf(i/) /'\n'>C *** /'n = '>C *printf(n/) /'\n'>C
		L2l&Ii=t ?(t>0)3 ?=4 *** если t>0 значение степени найдено, переход в подсчёт переменных
	P2
		Yl 31=i ?(l>0)1 ?=5 *** l должно быть больше 0, потому что первое значение комплекса это количество переменных в функции
	P3
		*** /'d = '>C *printf(d/) /'\n'>C
		l-1*32+i=t Oj t%=p t=q
		*** /'t = '>C *printf(t/) /'\n'>C
		*** /'p = '>C *printf(p/) /'\n'>C
		?(p<=d)4 p=d
	P4
		?(i=0)2 Yi ?=1
	P5
		*** /'t = '>C *printf(t/) /'\n'>C
		*** /'j = '>C *printf(j/) /'\n'>C
		*** /'d = '>C *printf(d/) /'\n'>C
**


*** ****************************************************************************************
*** ************************************  PUA  *********************************************
*** ****************************************************************************************


*** тестирование функции преобразования уолша-адамара
bool_pua_test(/)
	@+L1(10000000)
	
	28=n In+10=t
	@+L3(t)
	@+F2(100)
	*** 32=L1.0
	
	
	OQ2 @'0101'>F2
	*** OQ2 @'0011'>F2
	*** OQ2 @'01010101'>F2
	*** OQ2 @'10010101'>F2
	*** OQ2 @'11111111'>F2
	*** OQ2 @'0001000100011110'>F2
	*** OQ2 @'10100100'>F2
	*** OQ2 @'11000011'>F2
	*** OQ2 @'11000000'>F2
	*** OQ2 @'0001000100011110000100010001111000010001000111101110111011100001'>F2
	*** OQ2 @'0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111'>F2
	*** OQ2 @'1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111'>F2
	*** OQ2 @'0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101'>F2
	*** OQ2 @'0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101'>F2
	*** OQ2 @'01100000'>F2
	*** OQ2 @'01110111'>F2
	*BFinput(F2/L1)
	
	
	/'t = '>C *printf(t/) /'\n'>C
	*** *BFrand(L1, n/L1) /'ok\n'>C
	
	
	*BFoutput_string(L1/) /'\n'>C
	*BFpua(L1/L3)
	*sprint_complex(L3/) /'\n'>C
	
	
**


*** ****************************************************************************************


*** превращение булева вектора в характеристический вектор
toCharactVect(L1/L2)
	Oi=j+1=l L1.0=n In=Q2
	P1
		Ij&L1l>j+2;3-1=L2i Di Dj ?(j>Q2)3 ?(j>31)2 ?=1
	P2
		Oj Dl ?(l<Q1)1
	P3
**


*** ****************************************************************************************


*** Обёртка для алгоритма преобразование Уолша-Адамара
BFpua(L1/L2)
	*toCharactVect(L1/L2)
	*sprint_complex(L2/) /'\n'>C
	*BFpuaAlg(L2, 0/L2)
**


*** ****************************************************************************************


*** преобразование уолша-адамара
*** 
***  a   b   c   d
*** a+b a-b c+d c-d
***  e   f   g   h
*** e+g f+h e-g f-h
*** b - граница
*** e - сдвиг для алгоритма автокорреляции (не то e, что выше)
BFpuaAlg(L2, e/L2)
	Op=j=k 1=i=s Q2-1=n/2+1=m  *** 1<L1.0-1=n/2+1=m
	/'n = '>C *printf(n/) /'\n'>C
	P1
		 Ik=s Op=j ?(s>m)5 Dk
		P2
			L2j=a j+s=l L2l=b *** /'22\n'>C
			*** /'a = '>C *sprintf(a/) /'\n'>C
			*** /'b = '>C *sprintf(b/) /'\n'>C
			a+b=L2j a-b=L2l ?(e=0)3
			*** возможно плохая идея приводить по модулю
			L2j;ffffffffh>e=L2j&I30<1=t L2j|t=L2j
			L2l;ffffffffh>e=L2l&I30<1=t L2l|t=L2l
			*** /'33\n'>C
			*** /'	j = '>C *printf(j/) /'\n'>C
			*** /'	l = '>C *printf(l/) /'\n'>C
			*** /'	p = '>C *printf(p/) /'\n'>C
			*** /'	s = '>C *printf(s/) /'\n'>C
			*** /'	m = '>C *printf(m/) /'\n'>C
		P3
			Dj Dp ?(l>=n)1 ?(p>=s)4
			*** /'s = '>C *sprintf(s/) /'\n'>C
			*** /'j = '>C *sprintf(s/) /'\n'>C
			*** /'l = '>C *sprintf(s/) /'\n'>C
			?=2
			*** ?=5
	P4
		j+s=j Op ?=2
	P5 *** /'qq\n'>C
		*** /'Q2 = '>C *printf(Q2/) /'\n'>C
**



*** /'a = '>C *printf(a/) /'\n'>C
*** /'b = '>C *printf(b/) /'\n'>C
*** /'c = '>C *printf(c/) /'\n'>C
*** /'d = '>C *printf(d/) /'\n'>C
*** ffffffffh=t /'t = '>C *sprintf(t/) /'\n'>C
*** 0-1=t /'t = '>C *printf(t/) /'\n'>C
*** /'L3l = '>C *sprintf(L3l/) /'\n'>C


*** ****************************************************************************************
*** *************************************  Moebius  ****************************************
*** ****************************************************************************************


*** тестирование функции преобразования Мёбиуса
bool_moebius_test(/)
	@+L1(100)
	@+L3(100)
	@+F2(100)
	*** 32=L1.0
	*** OQ2 @'01010011'>F2
	*** OQ2 @'01010101'>F2
	*** OQ2 @'01110101101010101010101010101001'>F2
	*** OQ2 @'11111111111111111111111111111111'>F2
	*** OQ2 @'01010101010101010101010101010101'>F2
	*** OQ2 @'0001000100011110'>F2
	 OQ2 @'0001000100011110000100010001111000010001000111101110111011100001'>F2
	*** OQ2 @'00000000000000001111111111111111'>F2
	*** OQ2 @'0111010110101010101010101010100101010101010101010101010101101101'>F2
	*** OQ2 @'1111111111111111111111111111111111111111111111111111111111111111'>F2
	*** OQ2 @'0101010101010101010101010101010101010101010101010101010101010101'>F2
	*** OQ2 @'0000000000000000000000000000000011111111111111111111111111111111'>F2
	*** OQ2 @'00000000000000000000000000000000000000000000000000000000000000001111111111111111111111111111111111111111111111111111111111111111'>F2
	*** OQ2 @'0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111'>F2
	*** OQ2 @'1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111'>F2
	*** OQ2 @'0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101'>F2
	*** *printf(Q2/) /'\n'>C
	*** /F2>C /'\n'>C
	*** *printf(Q2/) /'\n'>C
	*BFinput(F2/L1)
	*** *printf(L1.0/) /'\n'>C
	*** /'Q1 = '>C *printf(Q1/) /'\n'>C
	*BFoutput_string(L1/) /'\n'>C /'\n'>C
	*** *moebiusTransform_mod(L1/L3)
	*mobiusTransform(L1/L3)
	
	*** *BFoutput(L1/) /'\n'>C
	*BFoutput_string(L3/) /'\n'>C /'\n'>C
	*** *BFoutput(L3/) /'\n'>C
	
	*** *moebiusTransform_mod(L3/L1)
	*mobiusTransform(L3/L3)
	*BFoutput_string(L3/) /'\n'>C /'\n'>C
	*** *BFoutput(L1/) /'\n'>C
	
	
**


*** ****************************************************************************************


*** Функция преобразование мобиуса для булева вектора
***
*** b - граница
***
mobiusTransform(L1/L2)
	@+L3(100)
	*** /'L1 = '>C *BFoutput_string(L1/) /'\n'>C
	Q1=Q2-1/2=n L1.0=L2.0 1=i=l Os *** <L1.0=k
	*** *printf(Q1/) /'\n'>C
	*** /'n = '>C *printf(n/) /'\n'>C
	P1
		L1i=g
		*** /'g = '>C *printf(g/) /'\n'>C
		g<1&aaaaaaaah^g=g
		g<2&cccccccch^g=g
		g<4&f0f0f0f0h^g=g
		g<8&ff00ff00h^g=g
		g<16&ffff0000h^g=L2i Di ?(i<Q1)1
	P2
		1=i 1<s=l ?(l>n)5 Ds Ob
		P3
			i+l=j Db ?(j>Q2)2 ?(b>l)4 L2i^L2j=L2j Di ?=3
			*** /'i = '>C *printf(i/) /'\n'>C
		P4
			Ob i+l=i ?=3
	P5
**


*** ****************************************************************************************
*** *****************************************  ANF  ****************************************
*** ****************************************************************************************


test_printANF(/)
	@+L1(100)
	@+F2(100)
	@+L3(100)
	*** 32=L1.0
	*** OQ2 @'01010011'>F2
	*** OQ2 @'01010101'>F2
	*** OQ2 @'01110101101010101010101010101001'>F2
	*** OQ2 @'11111111111111111111111111111111'>F2
	*** OQ2 @'01010101010101010101010101010101'>F2
	*** OQ2 @'0001000100011110'>F2
	*** OQ2 @'0001000100011110000100010001111000010001000111101110111011100001'>F2
	*** OQ2 @'00000000000000001111111111111111'>F2
	*** OQ2 @'0111010110101010101010101010100101010101010101010101010101101101'>F2
	*** OQ2 @'1111111111111111111111111111111111111111111111111111111111111111'>F2
	*** OQ2 @'0101010101010101010101010101010101010101010101010101010101010101'>F2
	*** OQ2 @'01011111'>F2
	*** OQ2 @'11010110'>F2
	*** OQ2 @'11111111'>F2
	*** OQ2 @'0000000000000000000000000000000011111111111111111111111111111111'>F2
	*** OQ2 @'00000000000000000000000000000000000000000000000000000000000000001111111111111111111111111111111111111111111111111111111111111111'>F2
	*** OQ2 @'0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111'>F2
	*** OQ2 @'1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111'>F2
	*** OQ2 @'0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101'>F2
	*BFinput(F2/L1)
	*BFoutput_string(L1/) /'\n'>C
	1<L1.0=t
	@+F4(100)
	*printANF(L1/F4)
	/F4>C /'\n'>C
	
**


*** ****************************************************************************************



copySymbComplex(F1, F2/F2)
	Oi S2-1=n ?(Q1<1)3
	P1
		F1i@>F2 Di ?(Q2>n)2 ?(i<Q1)1 ?=3
	P2
		/'copySymbComplex: Q2 больше чем его размерность\n'>C
	P3
**


*** ****************************************************************************************


*** Вывод АНФ
*** Возможно лучше сделать без преобразование Мёбиуса, учитывая, что вектор придёт уже после него
*** t - вначале для контроля шагов s, далее для получения значения из булевой функции, потом для получения значения переменной, затем для записи номера переменной
*** s - шаг значений в булевой функции
*** f - если 1, надо добавить знак +
*** j - счётчик переменных, показывает какая переменная была последней
*** i - 
*** k - значение переменных для которых функция равна 1
printANF(L1/F2)
	Q1=n OQ2
	@+L3(n)
	@+F4(10)
	*mobiusTransform(L1/L3)
	*BFoutput_string(L3/) /'\n'>C
	L3.0-1=n Q3-1=m 1=i Of
	P1
		Os
		?(L3i=0)6 *** s=0 - начинаю с начала
	P2
		/'f = '>C *printf(f/) /'\n'>C
		?(s>31)6 L3.0=t ?(s>It)6 ?(f=0)3 Of @' + '>F2
	P3
		*** /'i = '>C *printf(i/) /'\n'>C
		*** /'s = '>C *printf(s/) /'\n'>C
		L3i&Is=t
		*** /'t = '>C *printf(t/) /'\n'>C
		Ds ?(t=0)2
		Oj i-1*32+s-1=k
		*** /'k = '>C *printf(k/) /'\n\n'>C
	P4
		1=f ?(j>n)2
		*** /'s = '>C *printf(s/) /'\n'>C
		*** /'i = '>C *printf(i/) /'\n'>C
		*** /'k = '>C *printf(k/) /'\n'>C
		?(k>0)5 @'1'>F2 ?=2
	P5 
		Ij&k=t Dj
		*** /'t = '>C *printf(t/) /'\n'>C
		?(t>0)7 ?=4
	P6
		Di ?(i<Q3)1 ?=8
	P7
		'X'@>F2 L3.0-j+1=t *** /'qq\n'>C
		/'i = '>C *printf(i/) /'\n'>C
		/'n = '>C *printf(n/) /'\n'>C
		/'j = '>C *printf(j/) /'\n'>C
		/'t = '>C *printf(t/) /'\n'>C
		OQ4 *n2s(t, 10/F4) *copySymbComplex(F4, F2/F2)
		*** /F2>C /'\n'>C
		?=4 *** ?(j<=n)4 ?=4
	P8
		Q2-3=Q2
**

*** ****************************************************************************************
*** ************************************  BF Generation ************************************
*** ****************************************************************************************


*** BFrand(L1/)
*** тестирование функции генератора булевой функции
bool_rand_test(/)
	@+L1(100)
	
	X X;10=t
	4=t
	*** /'main t = '>C *printf(t/) /'\n'>C
	*BFrand(L1, t/L1)
	/'Q1 = '>C *printf(Q1/) /'\n'>C
	*BFoutput(L1/) /'\n'>C
	
**

*** ****************************************************************************************


*** генерация булевой функции от n переменных
*** n - количество переменных
*** s - шаг, идёт до размера булевой функции
*** L1 - булева функция
*** i - текущий элемент из L1
*** величина сдвига
BFrand(L1, n/L1)
	Oc=j 1=i n=L1.0
	1<n=t>5+2=Q1-1=l OL1l
	*** /'n = '>C *printf(n/) /'\n'>C
	*** /'t = '>C *printf(t/) /'\n'>C
	*** /'Q1 = '>C *printf(Q1/) /'\n'>C
	*** /'L1.0 = '>C *printf(L1.0/) /'\n'>C
	16=s ?(L1.0>3)2 t;32=s *** c;t?-3 вместо ?(c>=t)3 ?
	P2 X>s=L1i c+s=c ?(c>=t)3 X>s<s|L1i=L1i c+s=c ?(c>=t)3 Di OL1i ?=2
	P3 *cutZerosBN(L1/L1) *** /'s = '>C *printf(s/) /'\n'>C
	*** *printf(L1.3/) /'\n'>C
	*** нужен ли cutZerosBN ?
**



*** ****************************************************************************************
*** ********************************  Input/Output/Weight  *********************************
*** ****************************************************************************************



*** сделать генератор
*** сделать алгоритм Мёбиуса
*** сделать цивилизованный вывод
*** нужно ли добавлять cutZerosBN ?
*** c;t-3 вместо ?(c>=t)3 ?


*** тестирование функций ввода/вывода, подсчёта размера булевой функции
bool_input_output_weight_test(/)
	@+L1(100)
	@+F2(100)
	*** 32=L1.0
	OQ2
	@'0111010110101010101010101010100101010101010101010101010101101101110111001001001101110101101010101010101010101001010101010101010101110101101010101010101010101001010101010101010101010101011011011101110010010011011101011010101010101010101010010101010101010101'>F2
	*** @'0111010110101010101010101010100101010101010101010101010101101101'>F2
	/F2>C /'\n'>C
	*** *printf(Q2/) /'\n'>C
	*BFinput(F2/L1)
	*** *printf(L1.0/) /'\n'>C
	/'Q1 = '>C *printf(Q1/) /'\n'>C
	*BFoutput(L1/) /'\n'>C
	*BFweight(L1/n)
	*printf(n/) /'\n'>C
	
**


*** ****************************************************************************************


*** 
*** L1.0 - размер булевой функции
*** ввод булевой функции
BFinput(F1/L2)
	OQ2 ?(Q1<1)6
	Q1=s-1&s?+6 *** проверка длины входных значений
	Oj=i=z
	*** задаётся размер комплекса
	*** число функций делится на 32 и добавляется ещё 2 элемента 1 под количество переменных один резервный, который в конце отбрасывается, если не понадобится
	Q1=n>5+2=Q2-1=t OL2t
	P1 Di=L2.0 n>1=n?+1 ∇L2.0 Oi *** подсчёт переменных в функции
	*** /'Q2 = '>C *printf(Q2/)  /'\n'>C *** размер функции
	*** /'L2.0 = '>C *printf(L2.0/)  /'\n'>C *** количество переменных
	Dj OL2j
	P2 F1i-48?+3 L2j ?=4
	P3 1<z=t L2j|t=L2j
	P4 Dz Di ?(i=Q1)7 i;32?-5 ?=2
	P5 Dj Oz OL2j ?=2
	P6 /'Ошибка: Возможно пустой символьный комплекс или длина булевой функции\n'>C
	P7 Q2-1=l ?(L2l>0)8 l=Q2 *** *cutZerosBN(L2/L2)
		 *** *printf(L2.0/) /' '>C *printf(L2.1/) /' '>C *printf(L2.2/) /' '>C *printf(Q2/)  /'\n'>C
	P8
**

*** ****************************************************************************************


*** 
*** n - размер булевой функции
*** вывод булевой функции со значениями переменных
BFoutput(L1/)
	?(Q1<1)3
	Oi
	P1 ?(i>=L1.0)2 /' X'>C *printf(i/) /' '>C Di ?=1
	P2 /'| f \n'>C Oi
	P3 ?(i>=L1.0)4 /'----'>C Di ?=3
	P4 /'----\n'>C
	Oz=c 1=i 1<L1.0=n
	P5 0=j 1<L1.0>1=l 1<z=q L1i&q>z=t Dc
		 *** *printf(c/) /' '>C
		 P8
			?(j>=L1.0)9 L1.0-j-1=w c-1&l>w=w /' '>C *printf(w/) /'  '>C l>1=l Dj ?=8
		 P9
			/'| '>C *printf(t/) /' '>C
		 Dz ?(z=32)6 ?(c=n)7 /'\n'>C ?=5
	P6 Oz Di ?(i=Q1)7 /'\n'>C ?=5
	P7 *** /'\n'>C
**

*** ****************************************************************************************


*** 
*** n - размер булевой функции
*** вывод булевой функции строкой или в столбик
BFoutput_string(L1/)
	?(Q1<1)3
	Oz=c 1=i 1<L1.0=n
	P1 1<z=t L1i&t>z=t Dc
		 *** *printf(c/) /' '>C
		 *printf(t/) *** /'\n'>C
		 Dz ?(z=32)2 ?(c=n)3 ?=1
	P2 Oz Di ?(i=Q1)3 ?=1
	P3 *** /'\n'>C
**


*** ****************************************************************************************


BFweight(L1/n)
	?(Q1<1)2 Oi=n Di
	P1 L1i%+n=n Di ?(i<Q1)1
	P2
**




*** *****************************
*** *****************************
*** ******			BACKUP		*******
*** *****************************
*** *****************************



*** /' = '>C *printf(/) /'\n'>C
*** Автокорреляция
*** 
*** 
*** 
BFautocor_bak(L1/L2)
	L1.0=m 1<m=n
	@+L3(n) n=Q3
	*toCharactVect(L1/L2)
	/'L2 = '>C *sprint_complex(L2/) /'\n'>C
	Oi=f+1=j /'		*************** Cycle1 ******************\n'>C
	P93									*** Начало cycle1
		Ok /'		*************** Cycle2 ******************\n'>C
	P94									*** Начало cycle2
		Ol=q j-1=o /'		*************** Cycle3 ******************\n'>C
	P95									*** Начало cycle3,4
		?(l>o)97
		k+l=p+q=t p+j=e
		*** /'q = '>C *sprintf(q/) /'\n'>C
		*** /'p = '>C *sprintf(p/) /'\n'>C
		*** /'e = '>C *sprintf(e/) /'\n'>C
		*** /'t = '>C *sprintf(t/) /'\n'>C
		*** /'L2p = '>C *sprintf(L2p/) /'\n'>C
		*** /'L2e = '>C *sprintf(L2e/) /'\n'>C
		*** /'L3t = '>C *sprintf(L3t/) /'\n'>C
		?(q>0)96 L2p+L2e=L3t Dl ?=95
	P96
		L2p-L2e=L3t Dl ?=95
	P97									*** триггер для 4го цикла основан на значении q
											*** если q>0, значит цикл уже проходил, переход к следующему шагу
		*** /'L3 = '>C *sprint_complex(L3/) /'\n'>C
		*** /'L2 = '>C *sprint_complex(L2/) /'\n'>C
		?(q>0)98 Ol j=q
		/'		*************** Cycle4 ******************\n'>C
		?=95
	P98
		j<1-1=o Ol /'		*************** Cycle5 ******************\n'>C
		/'L3 = '>C *sprint_complex(L3/) /'\n'>C
		/'L2 = '>C *sprint_complex(L2/) /'\n'>C
	P99									*** Начало cycle5
		?(l>o)100 l+k=t
		/'f = '>C *sprintf(f/) /'\n'>C
		/'t = '>C *sprintf(t/) /'\n'>C
		/'		Before\n'>C
		/'L2t = '>C *sprintf(L2t/) /'\n'>C
		/'L3t = '>C *sprintf(L3t/) /'\n'>C
		/'L3t = '>C *printf(L3t/) /'\n'>C
		L3t&I31=v L3t;ffffffffh>f=L2t&I30=v
		/'		After\n'>C
		/'L2t = '>C *sprintf(L2t/) /'\n'>C
		/'L3t = '>C *sprintf(L3t/) /'\n'>C
		/'L3t = '>C *printf(L3t/) /'\n'>C
		Dl ?=99
	P100
		/'f = '>C *sprintf(f/) /'\n'>C
		/'L3 = '>C *sprint_complex(L3/) /'\n'>C
		/'L2 = '>C *sprint_complex(L2/) /'\n'>C
		j<1+k=k ?(k<m)94 Di j<1=j ?(i<m)93
											*** триггер для перехода между
											*** двумя частями, основан на значении f
											*** если f>0, значит выход
		?(f>0)103 Oi Q2-1=t
	P101
		?(i>t)102 L2i*L2i=L2i Di ?=101
	P102
		Oi+1=f=j
		/'		*************** Cycle1 ******************\n'>C
		?=93
	P103
**





printANF_bak(L1/F2)
	Q1=n OQ2
	@+L3(n)
	@+F4(10)
	*mobiusTransform(L1/L3)
	*BFoutput_string(L3/) /'\n'>C
	L3.0-1=n Q3-1=m 1=i Of
	P91
		Os
		?(L3i=0)93 *** s=0 - начинаю с начала
	P92
		/'f = '>C *printf(f/) /'\n'>C
		?(s>31)93 L3.0=t ?(s>It)93 ?(f=0)96 Of @' + '>F2
	P96
		*** /'i = '>C *printf(i/) /'\n'>C
		*** /'s = '>C *printf(s/) /'\n'>C
		L3i&Is=t
		*** /'t = '>C *printf(t/) /'\n'>C
		Ds ?(t=0)92
		Oj i-1*32+s-1=k
		*** /'k = '>C *printf(k/) /'\n\n'>C
	P94
		1=f ?(j>n)92
		*** /'s = '>C *printf(s/) /'\n'>C
		*** /'i = '>C *printf(i/) /'\n'>C
		*** /'k = '>C *printf(k/) /'\n'>C
		?(k>0)97 @'1'>F2 ?=92
	P97 
		Ij&k=t Dj
		*** /'t = '>C *printf(t/) /'\n'>C
		?(t>0)95 ?=94
	P93
		Di ?(i<Q3)91 ?=100
	P95
		'X'@>F2 L3.0-j+1=t *** /'qq\n'>C
		/'i = '>C *printf(i/) /'\n'>C
		/'n = '>C *printf(n/) /'\n'>C
		/'j = '>C *printf(j/) /'\n'>C
		/'t = '>C *printf(t/) /'\n'>C
		OQ4 *n2s(t, 10/F4) *copySymbComplex(F4, F2/F2)
		*** /F2>C /'\n'>C
		?=94 *** ?(j<=n)94 ?=94
	P100
		Q2-3=Q2
**




BFpuaAlg_bak(L2, e/L2)
	Op=j=k 1=i=s Q2-1=n/2+1=m  *** 1<L1.0-1=n/2+1=m
	/'n = '>C *printf(n/) /'\n'>C
	P97
		 Ik=s Op=j ?(s>m)100 Dk
		P98
			L2j=a j+s=l L2l=b *** /'22\n'>C
			/'a = '>C *sprintf(a/) /'\n'>C
			/'b = '>C *sprintf(b/) /'\n'>C
			a+b=L2j a-b=L2l ?(e=0)96
			*** возможно плохая идея приводить по модулю
			L2j;ffffffffh>e=L2j&I30<1=t L2j|t=L2j
			L2l;ffffffffh>e=L2l&I30<1=t L2l|t=L2l
			*** /'33\n'>C
			*** /'	j = '>C *printf(j/) /'\n'>C
			*** /'	l = '>C *printf(l/) /'\n'>C
			*** /'	p = '>C *printf(p/) /'\n'>C
			*** /'	s = '>C *printf(s/) /'\n'>C
			*** /'	m = '>C *printf(m/) /'\n'>C
		P96
			Dj Dp ?(l>=n)97 ?(p>=s)99
			*** /'s = '>C *sprintf(s/) /'\n'>C
			*** /'j = '>C *sprintf(s/) /'\n'>C
			*** /'l = '>C *sprintf(s/) /'\n'>C
			?=98
			*** ?=100
	P99
		j+s=j Op ?=98
	P100 *** /'qq\n'>C
		*** /'Q2 = '>C *printf(Q2/) /'\n'>C
**